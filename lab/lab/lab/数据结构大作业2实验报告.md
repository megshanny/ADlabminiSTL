### 数据结构大作业2实验报告

\#2022201895 于佳鑫

#### 0. query_dfs

实验思路：

​	使用深度优先搜索的方法，找出以指定机场开始的航线。其中时间处理成了int类型。输入时，按照提示输入相应的机场编号和时间。

代码展示：

```cpp
DFSResult Planner::query_dfs(int airport_id, Data* data, int stime)
{   
    dfsResult.dfsData.clear();
    state.assign(state.size(), 0); //初始化容器
    dfs(airport_id,data,stime); //调用dfs函数求解
    return dfsResult;
}
```

结果展示：

![image-20231214161854508](C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161854508.png)

#### 1. query_bfs

实验思路：

​	使用广度优先搜索的方法，找出以指定机场开始的航线。其中时间处理成了int类型。输入时，按照提示输入相应的机场编号和时间。

代码展示：

```cpp
BFSResult Planner::query_bfs(int airport_id, Data* data, int stime)
{
    BFSResult bfsRes;
    state.assign(state.size(), 0);
    std::queue<Data> qu;
    bfsRes.bfsData.push_back(airport_id);
    for (int i = 0; i < datasize; i++)
    {
        if (data[i].dairport == airport_id && data[i].dtime > stime)
        {
            qu.push(data[i]);
            state[airport_id]=1;
            bfsRes.bfsData.push_back(data[i].aairport);
            state[data[i].aairport]=1;
            break;
        }
    }
    while (!qu.empty())
    {
        Data temp = qu.front();
        qu.pop();
        for (int i = 0; i < datasize; i++)
        {
            if (data[i].dairport == temp.aairport && state[data[i].aairport]==0 && data[i].dtime > temp.atime)
            {
                qu.push(data[i]);
                bfsRes.bfsData.push_back(data[i].aairport);
                state[data[i].aairport]=1;
                break;
            }
        }
    }
    return bfsRes;
}
```

结果展示：

![image-20231214161904402](C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161904402.png)

#### 2. query_connectivity

实验思路：

​	由于数据集不大，所以直接采用穷举的方法，计算出来结果。

代码展示：

```cpp
ConnectivityResult Planner::query_connectivity(int airport_1, int airport_2, Data* data)
{
    ConnectivityResult connectRes;
    for (int i = 0; i < datasize; i++)
    {
        if (data[i].dairport == airport_1)
        {
            if (data[i].aairport == airport_2)
            {
                connectRes.connectData.push_back({data[i]});
            }
            else
            {
                int mid_airport = data[i].aairport;
                Vector<int> temp;
                for (int j = 0; j < datasize; j++)
                {
                    if (data[j].dairport == mid_airport && data[j].aairport == airport_2 && data[i].atime < data[j].dtime)
                    { 
                        connectRes.connectData.push_back({data[i],data[j]});
                    }
                }
            }
        }
    }
    return connectRes;
}
```

结果展示：

<img src="C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161911219.png" alt="image-20231214161911219" style="zoom:67%;" />

#### 3. quary_shortest_path

实验思路：

​	使用深度优先搜索的方法，每次选取一个，计算总时间，如果超出了当前的最短时间，就跳过执行下一个。

代码展示：

```cpp
void time_dfs(int airport_id, int airport_2, Data* data, int start_time, int sum_time);

ShortestPathResult Planner::query_shortest_path(int airport_1, int airport_2, int start_time, int end_time, Data* data)
{
    pathRes.pathData.clear();
    min_time = end_time - start_time;
    pathTemp.clear();
    state.assign(state.size(), 0); // 初始化容器
    time_dfs(airport_1,airport_2,data,start_time,0);// 调用time_dfs求解
    return pathRes;
}
```

结果展示：

<img src="C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161929164.png" alt="image-20231214161929164" style="zoom: 67%;" />

#### 4. quary_mini_cost_path

实验思路：

​	使用深度优先搜索的方法，每次选取一个，计算总花费，如果超出了当前的最低花费，就跳过执行下一个。

代码展示：

```cpp
void cost_dfs(int airport_id, int airport_2, Data* data, int start_time, int end_time, int sum_cost)
MinimumCostPathResult Planner::query_minimum_cost_path(int airport_1, int airport_2, int start_time, int end_time, Data* data)
{
    pathTemp.clear();
    state.assign(state.size(), 0);
    costRes.costData.clear();
    cost_dfs(airport_1,airport_2,data,start_time,end_time,0);
    return costRes;
}
```

结果展示：

<img src="C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161932641.png" alt="image-20231214161932641" style="zoom: 67%;" />

#### 5. query_all_paths

实验思路：

​	和第二题类似，使用穷举的方法，计算出来所有的航线。

代码展示：

```cpp
AllPathsResult Planner::query_all_paths(int airport_1, int airport_2, int start_time, int end_time, Data* data)
{
    AllPathsResult allpathRes;
    for (int i = 0; i < datasize; i++)
    {
        if (data[i].dairport == airport_1 && data[i].dtime > start_time )
        {
            if (data[i].aairport == airport_2 && data[i].atime < end_time)
            {
                allpathRes.allpathData.push_back({data[i]});
            }
            else
            {
                int mid_airport = data[i].aairport;
                Vector<int> temp;
                for (int j = 0; j < datasize; j++)
                {
                    if (data[j].dairport == mid_airport && data[j].aairport == airport_2 && data[i].atime < data[j].dtime && data[j].atime <= end_time)
                    { 
                        allpathRes.allpathData.push_back({data[i],data[j]});
                    }
                }
            }
        }
    }
    return allpathRes;
}
```

结果展示：

<img src="C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20231214161935435.png" alt="image-20231214161935435" style="zoom: 67%;" />